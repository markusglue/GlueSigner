/*
* This program is free software; you can redistribute it and/or modify it under the terms of the 
* GNU Affero General Public License version 3 as published by the Free Software Foundation 
* with the addition of the following permission added to Section 15 as permitted in Section 7(a): 
* FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED BY Glue Software Engineering AG, 
* Glue Software Engineering AG DISCLAIMS THE WARRANTY OF NON INFRINGEMENT OF THIRD PARTY RIGHTS.
* 
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
* See the GNU Affero General Public License for more details. You should have received a copy 
* of the GNU Affero General Public License along with this program; if not, 
* see http://www.gnu.org/licenses or write to the Free Software Foundation, 
* Inc., 51 Franklin Street, Fifth Floor, Boston, MA, 02110-1301 USA.

* The interactive user interfaces in modified source and object code versions of this program 
* must display Appropriate Legal Notices, as required under Section 5 of the GNU Affero General Public License.
* 
* In accordance with Section 7(b) of the GNU Affero General Public License, 
* a covered work must retain the producer line in every PDF that is created or manipulated using GlueSigner.
* 
* For more information, please contact Glue Software Engineering AG at this address: info@glue.ch
*/

package android_GLUESigner.pdf.ui;

import java.io.IOException;

import net.sf.andpdf.pdfviewer.PdfViewerActivity;
import android_GLUESigner.ui.R;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Rect;
import android.text.Layout;
import android.text.StaticLayout;
import android.text.TextPaint;
import android.text.style.LineHeightSpan;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup.LayoutParams;
import android.widget.RelativeLayout;
import android_GLUESigner.models.SignatureInfo;
import android_GLUESigner.pdf.ui.PDFViewerFragment;

public class DragRectView extends View {


	private static final float MAX_TEXTSIZE = 80;

	public enum ZoomEvent {
		IN, OUT, NONE
	}

	private Paint mRectPaint;

	private int mStartX = 0;
	private int mStartY = 0;
	private int mEndX = 0;
	private int mEndY = 0;
	private int imageWidth;
	private int imageHeight;

	private boolean mDrawRect = false;
	public boolean isDragging = false;
	public boolean zoomEventOccured = false;

	private TextPaint mTextPaint = null;
	private Rect mRect;

	private boolean touchEnabled = true;

	private ZoomEvent zoomEvent = ZoomEvent.NONE;

	private PDFViewerFragment pdfViewerFragment;

	private boolean previewMode;


	public DragRectView(final Context context, final AttributeSet attrs,
			final int defStyle) {
		super(context, attrs, defStyle);
		init();
	}

	/**
	 * @param context
	 * @param pdfViewerFragment
	 */
	public DragRectView(Context context) {
		super(context);
		init();
		
	}
	
	public DragRectView(Context context, boolean previewMode){
		super(context);
		this.previewMode = previewMode;
		init();
	}

	public Rect getRect() {
		return this.mRect;
	}

	public void SetZoomEventOccured(ZoomEvent z) {
		this.zoomEventOccured = true;
		this.zoomEvent = z;
	}

	public void setTouchEnabled(boolean touchEnabled) {
		this.touchEnabled = touchEnabled;
		this.mDrawRect = touchEnabled;
	}

	/**
	 * Inits internal data
	 */
	private void init() {
		mRectPaint = new Paint();
		mRectPaint.setColor(getContext().getResources().getColor(
				android.R.color.holo_green_light));
		mRectPaint.setStyle(Paint.Style.STROKE);
		mRectPaint.setStrokeWidth(5); // TODO: should take from resources

		mTextPaint = new TextPaint();
		mTextPaint.setColor(getContext().getResources().getColor(
				android.R.color.holo_green_light));
		mTextPaint.setTextSize(20);
		// Set empty Rectangle on constrution
		mRect = new Rect(0, 0, 0, 0);
		if (previewMode){
			mTextPaint.setColor(getResources().getColor(R.color.black));
		    mRectPaint.setColor(getResources().getColor(R.color.black));
		}

	}

	@Override
	public boolean onTouchEvent(final MotionEvent event) {
		// Log.d("draw","drawnot " +event.getX() + " " + event.getY());
		if (touchEnabled) {
			switch (event.getAction()) {
			case MotionEvent.ACTION_DOWN:
				mDrawRect = false;
				mStartX = (int) event.getX();
				mStartY = (int) event.getY();
				invalidate();
				break;

			case MotionEvent.ACTION_MOVE:
				isDragging = true;
				final int x = (int) event.getX();
				final int y = (int) event.getY();

				if (!mDrawRect || Math.abs(x - mEndX) > 5
						|| Math.abs(y - mEndY) > 5) {
					mEndX = x;
					mEndY = y;
					invalidate();
				}

				mDrawRect = true;
				break;

			case MotionEvent.ACTION_UP:
				/*
				 * if (mCallback != null) { Rect rect = new
				 * Rect(Math.min(mStartX, mEndX), Math.min(mStartY, mEndY),
				 * Math.max(mEndX, mStartX), Math.max(mEndY, mStartX));
				 * mCallback.onRectFinished(new Rect(Math.min(mStartX, mEndX),
				 * Math.min(mStartY, mEndY), Math.max(mEndX, mStartX),
				 * Math.max(mEndY, mStartX))); Log.d("rectangle", "Rect is (" +
				 * rect.left + ", " + rect.top + ", " + rect.right + ", " +
				 * rect.bottom + ")"); }
				 */

				// as soon as rectangle is selected, update Activity Result

				// pdfViewerFragment.setActivityResult(RECT_SELECTED);
				invalidate();

				break;

			default:
				break;
			}

			return true;
		}
		return false;
	}

	float scaleFactor = 0;

	private SignatureInfo signatureInfo;

	@Override
	protected void onDraw(final Canvas canvas) {
		super.onDraw(canvas);
		if (mDrawRect) {
			// Log.d("draw", "drawrect =" + Boolean.toString(mDrawRect));
			// Log.d("draw", "dragging =" + Boolean.toString(isDragging));
			if (isDragging) {
				drawFromTouch(canvas);
				Log.d("draw", "fall 2 dragging and not isZooming");
				isDragging = false;

			} else if (!isDragging) {
				switch (zoomEvent) {
				case IN:
					this.mStartX *= 1.5;
					this.mStartY *= 1.5;
					this.mEndX *= 1.5;
					this.mEndY *= 1.5;
					break;
				case OUT:
					this.mStartX /= 1.5;
					this.mStartY /= 1.5;
					this.mEndX /= 1.5;
					this.mEndY /= 1.5;
					break;
				default:
					break;
				}

				drawFromTouch(canvas);

			}
			setResultRect();
		}

	}

	/**
	 * 
	 */
	private void setResultRect() {
		if (touchEnabled){
		mRect = new Rect(Math.min(mStartX, mEndX), Math.min(mStartY, mEndY),
				Math.max(mEndX, mStartX), Math.max(mEndY, mStartX));
		pdfViewerFragment.setNextEnabled(true);
		Log.d("rectangle", "Rect is (" + mRect.left + ", " + mRect.top + ", "
				+ mRect.right + ", " + mRect.bottom + ")");
		this.getSignatureInfo().setPageNumber(pdfViewerFragment.getmPage());
		}
	}
	
	public void setMRect(){
		mStartX = signatureInfo.getGraphicRect().left;
		mEndX = signatureInfo.getGraphicRect().right;
		mStartY = signatureInfo.getGraphicRect().top;
		mEndY = signatureInfo.getGraphicRect().bottom;
		mDrawRect = true;
		this.touchEnabled = false;
	}

	/**
	 * @param canvas
	 */
	private void drawFromTouch(final Canvas canvas) {
		/* todo signature set button remove in non wizard mode */
		
			switch (getSignatureInfo().getSignatureType()) {
			case NORMAL:

				drawBasicRectangle(canvas);
				
					drawPreviewText(canvas,
							(int) (Math.min(mStartX, mEndX) + mRectPaint
									.getStrokeWidth()),
							(int) (Math.min(mStartY, mEndY) + mRectPaint
									.getStrokeWidth()),
							(int) (Math.abs(mStartX - mEndX) - (mRectPaint
									.getStrokeWidth() * 2)),
							(int) (Math.abs(mStartY - mEndY) - (mRectPaint
									.getStrokeWidth() * 2)));
				

				zoomEvent = zoomEvent.NONE;
				break;
			case PICTURE:
				drawBasicRectangle(canvas);
					drawBitmapFromFile(canvas, pdfViewerFragment
							.getSignatureInfo().getImagePath());
					
					
					drawPreviewText(canvas,
							(int) (Math.min(mStartX, mEndX) + mRectPaint
									.getStrokeWidth()),
							(int) (Math.min(mStartY, mEndY) + mRectPaint
									.getStrokeWidth()),
							(int) (Math.abs(mStartX - mEndX) - (mRectPaint
									.getStrokeWidth() * 2)),
							(int) (Math.abs(mStartY - mEndY) - (mRectPaint
									.getStrokeWidth() * 2)));
				
				break;
			default:
				break;
			}

	

	}

	/**
	 * @param canvas
	 * @param imagePath
	 */
	private void drawBitmapFromFile(Canvas canvas, String imagePath) {
	
		Bitmap image = BitmapFactory.decodeFile(imagePath);
		canvas.drawBitmap(image, null,
				new Rect(Math.min(mStartX, mEndX), Math.min(mStartY, mEndY),
						Math.max(mEndX, mStartX), Math.max(mEndY, mStartX)),
				mRectPaint);
		
	}

	/**
	 * @param canvas
	 */
	private void drawBasicRectangle(final Canvas canvas) {
		Log.d("sgr","drawrect called");
		canvas.drawRect(Math.min(mStartX, mEndX), Math.min(mStartY, mEndY),
				Math.max(mEndX, mStartX), Math.max(mEndY, mStartY), mRectPaint);
<<<<<<< HEAD
		if(!previewMode){
=======
		if (!previewMode){
>>>>>>> 726b1c9901631862bfc03707cb3782ddd2c653f1
		canvas.drawText(
				"  (" + Math.abs(mStartX - mEndX) + ", "
						+ Math.abs(mStartY - mEndY) + ")",
				Math.max(mEndX, mStartX), Math.max(mEndY, mStartY), mTextPaint);
<<<<<<< HEAD
		}
=======
		
		}
		
>>>>>>> 726b1c9901631862bfc03707cb3782ddd2c653f1
	}

	/**
	 * @param canvas
	 */
	private void drawPreviewText(Canvas canvas, int x, int y, int width,
			int height) {
		Log.d("sigr",String.format("isinsetmode + %b", this.previewMode));
		SignatureInfo info = getSignatureInfo();
		int currentx = x;
		int currenty = y;
		String[] texts = { pdfViewerFragment.getActivity().getApplicationContext().getString(R.string.rect_text_name) + " " + info.getSignatureName(),
				pdfViewerFragment.getActivity().getApplicationContext().getString(R.string.rect_text_reason) + " " + info.getSignatureReason(),
				pdfViewerFragment.getActivity().getApplicationContext().getString(R.string.rect_text_location) + " " + info.getSignatureLocation() };
		float currentTextSize = MAX_TEXTSIZE;
		String longestText = "";
		float lastMeasuredWidth = width + 1;
		// get most characters = most width
		for (String text : texts) {
			if (text.length() > longestText.length())
				longestText = text;
		}
		float xindent = 0;
		float ylineheight = 0;
		// shrink till fits rect
		boolean heightOK = false;
		while (lastMeasuredWidth > width - (2 * xindent) && currentTextSize > 0) {
			currentTextSize = currentTextSize - 2;
			mTextPaint.setTextSize(currentTextSize);
			lastMeasuredWidth = mTextPaint.measureText(longestText);
			xindent = (mTextPaint.measureText("a"));
			ylineheight = Math
					.abs((mTextPaint.ascent() + mTextPaint.descent()));
			heightOK = (ylineheight * 1.5 * 3 < height);
			currentx = (int) (x + xindent);// set same text size for all texts
											// including ones with less
											// characters then longestText

		}
		// skip a line at current text size so that first text is drawn in rect.

		// draw each text
		if (width < 0)
			width = 0;
		for (String text : texts) {
			StaticLayout sl = new StaticLayout(text, mTextPaint, (int) (width),
					Layout.Alignment.ALIGN_NORMAL, 1, 1, false);
			canvas.save();
			canvas.translate(currentx, currenty);
			sl.draw(canvas);
			canvas.restore();
			currenty = (int) (currenty + 1.5 * ylineheight);
		}

	}
	
	//Not every drag rect view will be using the signatureInformation associated with the pdfviewerfragment.
	//Useful in case of existing signatures.
	
	public void setSignatureInfo(SignatureInfo signatureInfo){
		this.signatureInfo = signatureInfo;
	}

	public SignatureInfo getSignatureInfo() {
		return this.signatureInfo;
	}

	/**
	 * @param currenty
	 * @param ylineheight
	 * @return
	 */

	public void setMeasures(float width, float height) {
		this.imageHeight = (int) height;
		this.imageWidth = (int) width;
		this.setLayoutParams(new RelativeLayout.LayoutParams(imageWidth,
				imageHeight));
		requestLayout();
		invalidate();
	}

	/**
	 * @return the pdfViewerFragment
	 */

	/**
	 * @param pdfViewerFragment
	 *            the pdfViewerFragment to set
	 */
	public void setPdfViewerFragment(PDFViewerFragment pdfViewerFragment) {
		this.pdfViewerFragment = pdfViewerFragment;
	}

	public void setRectVisibleOnPage(int currentPage) {
		int sigPage = getSignatureInfo().getPageNumber();
		boolean visible = currentPage == sigPage;
		this.mDrawRect = visible;
		if (visible || touchEnabled){
			this.setVisibility(View.VISIBLE);
			
		}else{
			this.setVisibility(View.INVISIBLE);
		}
		
	}

}